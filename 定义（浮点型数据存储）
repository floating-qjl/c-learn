#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <math.h>
#include <string.h>
int main()
//整型与浮点型储存和取得的方式不一样
//IEEE 754规定，任意一个二进制浮点数V可以表示成以下的形式
//(-1)^S * M * 2^E
//(-1)^S表示符号位，当S=0时为正数，当S=1时为负数
//M表示有效数字（以科学计数法表示），大于等于1，小于2
//2^E表示指数位

{
	//1001   -  二进制
	//(-1)^0 * 1.001 * 2^(3)   -  科学计数法表示
	//S - 0
	//M - 1.001
	//E - 3
	//E - 实际为 3 + 127 = 130
	// float - 32bit位 - 1bit存储S，8bit存储E，23bit存储M
	// double - 64bit位 - 1bit存储S，11bit存储E，52bit存储M
	//因为二进制表示时，M 一定可以写成 1.xxxxxx 因此在存储时将1省略，增加小数位精度
	//同时规定，不论E为正数还是负数，都必须增加中间值（float为 0 到 255 ，double为 0 到 2047）
	//即32bit中间值为127，64bit中间值为1023
	//例如 数值 0.5
	//        000.1 - 二进制（0.1 表示 2^(-1)）
	//        （-1）^0 * 1.0 * 2^(-1)   -  科学计数法表示
	// S - 0
	// M - 1.0
	// E - -1
	//此时 E 的实际储存值为 -1 + 127 = 126



	int a = 9;
	//00000000000000000000000000001001 - 补码
	float* b = (float*)&a;
	//强制类型转换
	//0 00000000 00000000000000000001001 - 浮点型存储
	//换算为 (-1)^0 * 0.00000000000000000001001 * 2^(-126)
	//无限接近于零，因此输出 0 
	printf("a的值:%d\n", a);//9
	printf("*b的值:%f\n", *b);//0.000000

	*b = 9.0;
	//1001 - 二进制
	//换算为 (-1)^0 * 1.001 * 2^3
	//存储  0 10000010 0010000000000000000000 - 相当于补码
	//换算成整型  正数补码与原码相同  进行输出
	printf("a2的值:%d\n", a);//1091567616
	printf("*b2的值:%f\n", *b);//9.0
	return 0;
}
